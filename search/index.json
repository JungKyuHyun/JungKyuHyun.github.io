[{"content":"배포 전략(Deployment Strategies) Micro-Frontend(이하 MFE)를 도입하기전 배포 전략을 어떻게 세울지 고민해 보았다. MFE는 본질적으로는 독립적으로 배포되어야 하고 전체 코드베이스에 영향을 주지 않고 코드의 일부만 배포하게 된다.\n뭐 일단 나중에야 그렇게 되겠지만, 지금 당장 우리의 애플리케이션은 프로덕션 환경에서 이미 실행중이며, 이럴때는 어떻게 진행되면 좋을까. 여러가지 배포 전략을 살펴보며 개념을 익혀보자.\n빅뱅 릴리스(Big Bang Releases)  여러분은 우리 비즈니스의 복잡성을 이해하지 못해요 - 빅뱅 옹호자 -\n 빅뱅 릴리스는 프로젝트에 너무 많은 위험을 가져다 주지만, 특히 폭포수(waterfall) 모델에서 많이 사용되던 방식이다. 빅뱅 릴리스란 간단하게 말해 완전하게 기능을 갖는 것을 목표로 일부 코드에 대해 몇 달 동안 작업하는 경우이다. 그리고 이 릴리스를 통해 우리는 우리의 고객이 멋진 새로운 기능을 잘 사용하며 잘 적응해 줄 것이라고 믿는다.\n하지만 이러한 빅뱅 릴리스는 그 릴리스 범위에 대한 가정을 테스트하지 않고 범위를 엄격하게 정의하고 실행하게 된다. 실제 테스트는 이미 그 릴리스를 위한 상당한 투자가 이루어진 이후에나 가능하게 된다.\n 과연 모든 세부 사항을 정말 모두 고려할 수 있었을까, 완제품을 확신할 수 있는가\n 또한 빅뱅 릴리스는 일반적으로 어떤 특정 기능의 완전한(100%) 추가를 목표로 하므로 미치치 못하는 높은 기대치를 설정하게 한다. 오랜 시간이 소요되며 상당한 투자가 발생했기 때문이다. 당연히 기본 사항을 변경하는 것은 매우 힘들게 된다. 이미 모든 작업은 가정된 기능과 기능을 지원하도록 설계되었으며, 변경시 비용이 급증하면서 변경이 어렵거나 큰 비용의 증가 및 릴리스 기간이 미뤄지는 경우가 발생할 것이다. (때로는 이 릴리스에 관련된 사람이 집을 못가고 계속 야근을 하며 변경사항에 대응하게 된다.)\n 빅뱅 릴리스는 규모가 커지면 커질수록 모든 계란을 한 바구니에 담는 것과 동일하다. 큰 위험이 따르며, 문제가 생겨서 깨진 계란이 생겼더라도 다시 처음으로 돌아가긴 힘들다\n 문제는 여기가 끝나지 않는다. 만약 해당 기능이 기다린 유저의 기대에 부응하지 못하거나 높은 실적(트래픽 증가, 매출 증가, 회원수 증가 등)으로 이루어지지 못한다면 다 같이 고생한 팀은 팀대로 인정받지 못하고, 반대로 기다렸던 사용자들도 실망을 안고 우리의 애플리케이션을 떠나갈 수도 있다. 또한 중간에 트랜드가 바뀌는 경우 경쟁사를 따라가지 못하거나 트랜드에 뒤쳐진 것을 큰 공을 들여 개발하게되는 것일 수도 있다.\n그래서 우리는 빅뱅 릴리스보다는 사용자에게 작은 범위의 유용한 기능(기능, 프로모션, 변화 등)을 제공하고 발견 사항을 기반으로 더 많은 릴리스와 실제 문제를 해결, 가정 검증에 중점을 두어야 한다. 세상은 우리의 생각보다 더 빠르게 변화하며, 유일하게 지속 가능한 접근 방식은 작게 시작하여 생각을 테스트하고 반복을 통해 최적의 솔루션을 향해 점진적으로 진행하는 것이다.\n 빅뱅보단 소규모 출시를 하자\n 문득 궁금해 졌다. 빅뱅 릴리스는 항상 옳지 못한가? 당연히 아니다. 모든 것에는 은총알은 없든 \u0026lsquo;모든\u0026rsquo;이라는 단어를 대체할 수는 없다. 하지만 대부분의 경우 웹은 변화가 빠르고 사용자(소비자)들의 요구사항과 성향이 빠르게 변하기 때문에 빅뱅보단 소규모 릴리스가 더 적합한 것이다.\n반면 제품 개발/연구가 필요한 부분이라면 조금 다를 수 있다. 예를 들어 애플의 아이폰이나 삼성의 갤럭시 휴대폰을 보자. 기존보다 더 높은, 더 좋은 기능과 품질을 타켓으로 제품을 만들어야하고 더 나은, 더 최신의 디자인을 선보여야 한다. 이는 연구와 개발이 필요하다. 이런 경우는 빅뱅 릴리스를 통해 출시 일정을 보다 명확하게 잡고 각 부서에서는 그 일정에 맞춰 마케팅, 영업 전략, 사업 전략을 세우고 더 많은 시간을 할애할 수 있다.\n또한 이렇게 개발한 고도화된 기술의 제품은 경쟁 제품들이 이 제품을 따라잡기까지 시간이 걸리기 때문에 경쟁 우위를 확보할 수도 있으며, 일정 기간 꾸준한 수익을 가져다 줄 수 있다.\n다시 본론으로 다시 본론으로 돌아와서, 이러한 빅뱅 릴리스는 MFE에는 적합하지 않다. 대신 소규모 사용자 그룹에게 새로운 버전의 MFE를 릴리스할 것이며, 이를 위한 몇가지 배포 전략에 대해 살펴보자.\nBlue-Green Deployment 블루-그린 배포(Blue-Green Deployment)는 마지막 테스트 환경이 나머지 플랫폼에 대해 실제 실행 중인 프로덕션 환경에서 테스트의 마지막 단계를 수행해야 한다는 가정으로부터 시작된다. 애플리케이션 또는 마이크로 서비스의 이전 버전에 있떤 사용장 트래픽을 이전 버전과 거의 동일한 새 버전으로 점진적으로 이전하는 애플리케이션 릴리스 모델이며, blue와 green이라는 두 개의 동일한 프로덕션 환경을 실행하여 가동 중지 시간과 위험을 줄이는 기술이다. 새 버전을 배포한 후 프로덕션 환경에서 테스트의 모든 이점을 얻으면서 사용자를 새 버전으로 리다이렉션하지 않고 프로덕션에서 새 코드를 테스트 할 수 있다.\n그리고 모든 테스트가 통과되면 트래픽의 100%를 MFE의 새 버전으로 리다이렉션할 준비가 되며, 이 전략은 사용자에게 영향을 주지 않고 모든 테스트를 수행할 수 있기 때문에 새로운 MFE를 배포할 위험을 줄여준다.\n이전 버전을 blue 환경, 새 버전을 green 환경으로 부르며, 프로덕션 트래픽이 블루에서 그린으로 완전히 이전되면, 블루를 롤백에 대비하여 남겨두면 된다. 이 기술을 배포로 인한 다운타임을 제거할 수 있으며, 새 버전에서 예상치 못한 일이 발생할 수 있으므로 blue를 바로 폐기하지 말고 롤백해야 하는 경우가 발생했을때 바로 blue로 전환하여 마지막 버전으로 롤백할 수 있다.\n참고로 데이터베이스 마이그레이션과 같이 시간이 많이 걸리는 작업에 대한 유지 관리 기간 동안 정적 유지 관리 페이지를 표시하도록 경로 매핑 패턴을 조정할 수 있으며, 블루-그린 배포로 인해 업데이터 중 그린 데이터베이스와 블루 데이터베이스 간에 불일치가 발생할 수 있으므로, 데이터 무결성을 위해 단일 데이터베이스를 구성한다.\nCanary Releases 카나리아 릴리스(Canary Releases)에서는 모든 테스트를 통과한 후 모든 트래픽을 새 버전으로 전환하지 않으며, 대신 새로운 MFE 버전으로 트래픽을 점차 완화한다. 오류율 증가 또는 사용자 참여 감소와 같이 새로운 프론트엔드를 소비하는 라이브 트래픽의 메트릭을 모니터링하면서 그에 따라 트래픽을 늘리거나 줄일 수 있다.\nBlue-Green Deployment / Canary Releases 두 방식 모두 트래픽을 형성하거나 트래픽을 한 버전에서 다른 버전으로 전환하는 라우터가 필요하다. 라우터는 선택한 아키텍처에 따라 클라이언트측, 서버측, 에지측에서 처리될 수 있다.\n 클라이언트측 라우팅: 정적 JSON 또는 백엔드 API를 통해 전달된 애플리케이션 쉘 구성 에지측 라우팅: 엣지에서 실행되는 로직(e.g. AWS Lambda@Edge) 서버측 라우팅: 애플리케이션 서버 로직, API 게이트웨이, 로드 밸런서  Strangler Pattern 교살자 패턴(Strangler Pattern)은 기존 웹 애플리케이션이 있고 MFE를 도입할때 유용하게 사용할 수 있다. 물론 MFE를 도입할때 전체 애플리케이션이 MFE로 전부 다시 작성될 때가지 기다릴 수도 있겠지만, 현실에선 교살자 패턴이 더 적절한 경우가 많다.\n교살자 패턴이란 완전히 새로운 애플리케이션이 준비될 때까지 기다리는 대신 애플리케이션의 일부를 릴리스하여 비즈니스와 사용자를 위한 증분 가치(Incremental value)를 생성한다는 아이디어에서 비롯된다. MFE를 구축하고 레거시 애플리케이션과 같이 유지하며 애플리케이션의 새로운 부분을 개발할 때마다 전체 레거시 애플리케이션이 MFE 플랫폼으로 완전히 대체될 때까지 레거시 애플리케이션의 다른 부분을 대체한다. 애플리케이션 영역이 아직 MFE에 대한 준비가 되지 않는 경우 라우터는 사용자를 레거시 플랫폼으로 리다이렉션 시킨다.\n도살자 패턴을 사용하면 회사가 부담없이 감수할 수 있는 위험을 탐색한 다음 이를 분석한 후 올바른 구현을 설계할 수 있다.\n","date":"2022-04-24T00:00:00+09:00","permalink":"https://JungKyuHyun.github.io/p/%EB%B0%B0%ED%8F%AC-%EC%A0%84%EB%9E%B5deployment-strategies/","title":"배포 전략(Deployment Strategies)"},{"content":"window.confirm() 프론트엔드 개발을 하다보면, 의외로 간단하게 사용했던 Web API인 window.confirm()가 그리울 때가 있다. 사용자에게 yes/no만 간단하게 요구하는 경우가 그러하다. 아래 그림처럼 어떤 리소스를 삭제하기 전에 사용자에게 한번 더 확인한다든지 그런 UI이다.\n사용하기도 간단하고 UI 컴포넌트를 추가할 필요도 없으며, 추가로 저 confirm창에 대한 상태 또한 관리하지 않아도 된다. 단지 이 함수의 시그니처에서도 알 수 있듯이 사용자가 선택하여 반환된 boolean 값에 의존하여 이후 로직을 설계하기만 하면 된다.\n window.confirm(message?: string): boolean\n 하지만 사용자가 적은 관리자 UI가 아니고선 사실 사용하기 쉽지 않다. 대부분의 웹은 자신들만의 특정한 UI 컨셉을 가지고 있으며 그것에 맞게 디자인, 위치 등을 수정할 수 없는 window.confirm 같은 Web API를 사용할 수가 없다. 또한 confirm이나 alert 등의 Web API는 스크립트 실행을 일시 중지하고 그 창이 닫힐 때까지 사용자가 페이지의 다른 부분과 상호 작용하는 것을 허용하지 않기 때문에 때로는 사용자 경험이 좋지 못하다.\n위에서 보듯 window.confirm은 정말 단순하지만 실제로 사용하기에는 그 댓가가 너무 크다.\n에이, 그러면 Modal을 직접 구현해서 만들면 되지 맞다. 틀린 말이 절대 아니다. 직접 구현해서 사용하면 되고 그렇게 만들었다고 틀린거나 동작이 이상한건 없다. 단지 관리 포인트(상태)가 늘어날 뿐이다. 이를 개선하기 위해 커스텀 훅으로 상태를 관리하는 부분을 뺀다든지 할 수 있겠지만, 여전히 window.confirm만큼 심플하지 않다.\n간단함을 포기하는게 답인가 그런건 아니다. 예를들어 react-toastify 같은 라이브러리에서 볼 수 있듯이 충분히 개선할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  import { ToastContainer, toast } from \u0026#34;react-toastify\u0026#34;; import \u0026#34;react-toastify/dist/ReactToastify.css\u0026#34;; function App() { const notify = () =\u0026gt; toast(\u0026#34;Wow so easy!\u0026#34;); return ( \u0026lt;div\u0026gt; \u0026lt;button onClick={notify}\u0026gt;Notify!\u0026lt;/button\u0026gt; \u0026lt;ToastContainer /\u0026gt; \u0026lt;/div\u0026gt; ); }   잠깐 다른 라이브러리를 언급한 이유는 이 문제를 개선할 수 있는 방법은 여러 가지가 존재하고 그중 한가지를 보여주려 하기 때문이다.\n처음에는 이런 문제를 해결할때 종종 사용했던 context API를 사용하려 했다. 하지만 우리의 앱은 이미 여러 사람들이 잠깐잠깐 거쳐가면서 추가해 놓은 Provider Hell을 겪고 있었다.\n1 2 3 4 5 6 7 8 9 10 11  function App() { return ( \u0026lt;AProvider\u0026gt; \u0026lt;BProvider\u0026gt; \u0026lt;CProvider\u0026gt; \u0026lt;DProvider\u0026gt;...\u0026lt;/DProvider\u0026gt; \u0026lt;/CProvider\u0026gt; \u0026lt;/BProvider\u0026gt; \u0026lt;/AProvider\u0026gt; ); }   그래서 이번엔 조금 다른 방식으로 문제를 해결해 보자는 생각을 했고 그 방식을 적어 보려고 한다.\n간단하면서도 유연하게 만들자 Modal 컴포넌트의 경우 요구 사항에 따라 미세하게 변경되는 경우가 많았다. 그래서 window.confirm과 같이 yes/no에 대해서 사용할 수 있는 컴포넌트만 추상화하기로 결정했고, 그 외의 부분은 미리 추상화 놓은 Modal 컴포넌트를 통해 선언적으로 만드는 것이 더 낫다고 판단했다.\n이렇게 범위로 정하고 나니깐 내가 만들어야할 window.confirm와 유사한 함수의 시그니처를 정할 수 있었다.\n modalHook(args: ModalProps): Promise\u0026lt;boolean\u0026gt;\n 이 함수는 기존에 사용해왔던 Modal의 인터페이스를 그대로 가져와 매개변수로 사용하고 Modal를 렌더링해주며, 확인/취소에 따라 Promise를 통해 boolean 값을 반환하는 간단한 함수이다. 여기서 기존에 추상해 놓은 Modal의 인터페이스를 그대로 가져온 이유는 기존 추상화된 Modal의 유연함을 그대로 가져가면서도 기존 개발자들이 사용하던 인터페이스를 훼손하지 않음으로서 기존 인터페이스에 대한 그대로 유지함을 목적으로 했다.\nmodalHook demo code 실제 코드를 적을 수는 없어서, 스펙을 최대한 간소화한 데모 코드의 시그니처는 아래와 같다.\n modalHook(message?: string): Promise\u0026lt;boolean\u0026gt;\n 데모 코드는 간단히 window.confirm과 동일하게 message만 받도록 수정했다. 그외의 구현체는 대부분 동일하기 때문에 실제 프로젝트에 적용할 때도 상황에 맞게 약간만 변경해 준다면 문제 없다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  import ReactDOM, { unmountComponentAtNode } from \u0026#34;react-dom\u0026#34;; const bodyNode = document.querySelector(\u0026#34;body\u0026#34;); interface ModalProps { open?: boolean; message?: string; onConfirm?: (e: React.MouseEvent\u0026lt;HTMLButtonElement, MouseEvent\u0026gt;) =\u0026gt; void; onCancel?: (e: React.MouseEvent\u0026lt;HTMLButtonElement, MouseEvent\u0026gt;) =\u0026gt; void; } export function Modal({ open = false, message = \u0026#34;\u0026#34;, onCancel, onConfirm, }: ModalProps) { return ( \u0026lt;dialog open={open}\u0026gt; \u0026lt;p\u0026gt;{message}\u0026lt;/p\u0026gt; \u0026lt;button onClick={onCancel}\u0026gt;취소\u0026lt;/button\u0026gt; \u0026lt;button onClick={onConfirm}\u0026gt;확인\u0026lt;/button\u0026gt; \u0026lt;/dialog\u0026gt; ); } export function modalHook(message?: string): Promise\u0026lt;boolean\u0026gt; { const modalNode = document.createElement(\u0026#34;div\u0026#34;); modalNode.id = \u0026#34;kyuhyun-modal\u0026#34;; bodyNode?.append(modalNode); return new Promise((resolve) =\u0026gt; { const handleReolve = (res: boolean) =\u0026gt; { unmountComponentAtNode(modalNode); resolve(res); bodyNode?.removeChild(modalNode); }; ReactDOM.render( \u0026lt;Modal open onConfirm={() =\u0026gt; handleReolve(true)} onCancel={() =\u0026gt; handleReolve(false)} message={message} /\u0026gt;, modalNode ); }); }   코드를 보면 특별히 이해가 어렵거나 특이한 로직은 없어 설명은 생략한다. 다만 react 18 버전 이상을 쓴다면 ReactDOM.render부분만 변경해 줘도 좋을거 같다. (참고: ReactDOMClient)\n실제 코드에서 테스트 해보면 위에서 만든 modalHook이 windonw.confirm과 유사한 방식으로 잘 동작하는 것을 확인할 수 있다. 만약 별도의 Modal 라이브러리를 사용한다면 위의 모달 구현체 부분과 타입만 약간 수정하면 그대로 적용이 가능하다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  import { modalHook } from \u0026#34;./Modal\u0026#34;; export default function App() { return ( \u0026lt;div className=\u0026#34;btn-container\u0026#34;\u0026gt; \u0026lt;button onClick={() =\u0026gt; { const agree = window.confirm(\u0026#34;정말 삭제하시겠습니까?\u0026#34;); if (agree) { alert(\u0026#34;삭제 좋아!\u0026#34;); } else { alert(\u0026#34;삭제 안돼!\u0026#34;); } }} \u0026gt; 삭제하기(window.confirm) \u0026lt;/button\u0026gt; \u0026lt;button onClick={async () =\u0026gt; { const agree = await modalHook(\u0026#34;정말 삭제하시겠습니까?\u0026#34;); if (agree) { modalHook(\u0026#34;삭제 좋아!\u0026#34;); } else { modalHook(\u0026#34;삭제 안돼!\u0026#34;); } }} \u0026gt; 삭제하기(modalHook) \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }   데모 영상  감사합니다.\n","date":"2022-04-20T00:00:00+09:00","image":"https://JungKyuHyun.github.io/p/window.confirm%EC%B2%98%EB%9F%BC-modal%EC%9D%84-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%97%86%EC%9D%84%EA%B9%8C/window-confrim_hu85ca61163faa13fa410b880d5b9b2ffc_32347_120x120_fill_box_smart1_3.png","permalink":"https://JungKyuHyun.github.io/p/window.confirm%EC%B2%98%EB%9F%BC-modal%EC%9D%84-%EB%A7%8C%EB%93%A4-%EC%88%98-%EC%97%86%EC%9D%84%EA%B9%8C/","title":"window.confirm처럼 Modal을 만들 수 없을까?"},{"content":"Microservice 마이크로 프론트엔드(Micro-Frontends)는 요즘 흔히 이야기가 나오는 마이크로서비스 아키텍처에서 영감을 받은 새로운 아키텍처이다. 이 아키텍처의 핵심 아이디어는 모놀리식(monolithic) 코드베이스를 더 작은 부분으로 나누어,\n 여러 팀이 독립적으로 작업할 수 있으며 배포 규모가 작고 장애는 단일 서비스에만 직접 관련되게 된다. 또한 프레임워크와 프로그래밍 언어를 개발 팀에 맞게 자유롭게 선택할 수 있으며, 초기 출시 기간도 짧고 서비스 단위로 명확한 아키텍처 경계를 가지고 있다.  (당연히 위의 이야기는 잘 구축되었을 때의 해피 케이스이므로 현실에선 저렇지 않다고 너무 모라고 하시지 마시고, 열린 마음으로 계속 글을 읽어주세요ㅎㅎ)\n사실 위의 장점은 마이크로 프론트엔드만의 장점이기 보다는 마이크로서비스가 갖는 장점이긴 한데 대부분 유사한 이점을 가지고 있다. 그리고 당연히 단점도 존재한다.\n 디버깅의 복잡성 증가 및 테스트가 어려워짐: 한가지 서비스에서 발생한 작은 버그 코드가 이 서비스에 의존하는 유관 서비스들로 퍼져 서비스가 장애가 난 원인의 근본 원인을 찾기가 더욱 힘들다. 장애(실패) 지점이 여러 서비스에서 존재 책임감 부족 버전 관리 지옥\u0026hellip; 네트워킹, 지속성 계층, 통신 프로토콜, 보안 및 기타 여러 수준에서의 복합성 처리  어떤 이야기든 결론은 비슷한거 같지만, 우리 제품의 상황에 맞는 선택과 아키텍처를 적용하는게 중요하다.\nMicro-frontend 등장 사실 마이크로 프론트엔드가 대부분의 서비스에서 필요한 부분은 아니었다. 왜냐하면 모든 비즈니스 로직은 서버에서 실행되었으며 클라이언트는 그 계산 결과만 표시해주는 단순한 씬 클라이언트(thin client)에 불과했기 때문이다.\n하지만 시간이 지나고 우리의 웹은 사용자와 더 많은, 더 나은 상호 작용들이 늘어났으며, 프론트엔드의 크기는 점점 비대해졌다. 이젠 더이상 씬 클라이언트(thin client)라고 부를 수 없게 된 것이다. 또한 프론트엔드의 기술을 매년 진화하고 트랜드가 너무 빨리 바뀌면서 아무리 잘 관리한 프로젝트라도 몇년 후에는 그 것을 관리할 수 있는 개발자를 뽑기조차 힘들어졌다. 그렇다고 무턱대고 프로젝트 전부를 새로운 기술과 코드 베이스로 마이그레이션하거나 리펙토링하는 것은 현실적으로 힘들었으며, 이것들로 인해 새로운 기능들을 미룰 수도 없는 상황이 된다. (사실 JQuery를 사용하지 않게 될 줄은 꿈에도 몰랐다.)\n우리가 가진 모놀리식 접근 방법으로는 해결하기 어려워졌고, 백엔드에서 마이크로 서비스를 통해 비슷하게 문제를 해결했듯이 프론트엔드에서도 이를 도입하여 문제를 해결하고자 했다.\nMicro-frontend에 대해 좀더 생각해보자 프론트엔드를 단순하게 마이크로 서비스처럼 나눈다고 생각했을 때는 간단하게 생각할 수도 있지만, 그건 HTML을 여러개 나누어 합친다는 식으로 생각했을 때 이야기이다. 생각보다 복잡한 문제가 많이 존재한다.\n 전역 변수는? 기존에 번들링 했던 여러 assets들은? 개별 서비스에서 URL에 따라 잘 연동될 수 있을까? 로그인 관리는? 각각의 서비스가 모두 리소스를 새로 만들어 사용한다면 사용자의 컴퓨터의 자원이 근방 고갈될텐데 등\u0026hellip;\n 위와 같은 이유를 포함해서 많은 기술적, 경험적 이유를 통해 마이크로 프론트엔드를 구축하는 것은 매우 어려운 작업이었으나, 최근에는 이와 관련해 꽤 많은 솔루션과 실제 구축 사례들이 컨퍼런스나 블로그 글 등을 통해 많이 발표되고 있다. 우리의 프론트엔드의 코드베이스가 폭발적으로 증가하고 다른 주기를 갖는 여러 프론트엔드 팀이 계속 생겨나고 있다면 마이크로 프론트엔드는 이때 발생하는 여러 문제를 나름 효과적으로 해결할 수 있는 한 방법이 될 것이다.\n 추가 장점1: 큰 모놀리식 저장소보다 여러 개의 작은 저장소를 사용하여, 문서를 쉽게 최신으로 유지할 수 있으며, 더 작은 커밋 히스토리를 유지할 수 있다. 추가 장점2: 외부 개발자 등과 함께 일할때 코드 베이스를 분리하여 개발을 요청한 범위 이외의 저장소에는 쉽게 접근을 막을 수도 있다. 추가 장점3: POC(최소 실행 가능한 제품)을 만들어 피드백을 받거나, A/B테스트 등을 하는 등의 비즈니스 관점에서도 마이크로 프론트엔드는 충분히 매력적이다. 추가 단점1: 어떤 코드가 어떤 저장소에 있는지 아는 것이 미덕이 되고, 시스템을 완전히 이해하려면 훨씬 더 많은 전문 지식이 필요하게 될 수 있다. 추가 단점2: 유지 보수가 만만치 않다.   여기까지 정말 간단하게나마 마이크로 서비스부터 마이크로 프론트엔드의 등장까지 요약해 봤다. 이제 조금씩 세부적으로 들여다 보자. 먼저 샘 뉴먼의 저서 마이크로서비스 아키텍처 구축에 나온 마이크로서비스 원칙에 대해서 먼저 살펴보려고 한다.\nMicroservice 원칙 아래와 같은 원칙을 수용하여 마이크로서비스를 개발하는 것을 권한다. 물론 마이크로 프론트라고 예외는 아니다.\n[출처] https://samnewman.io/talks/principles-of-microservices\n비즈니스 도메인을 중심으로 모델링 이는 도메인 중심 설계에서 이야기한 핵심 원칙이다. 각 소프트웨어는 조직이 하는 일을 반영하고, 우리는 비즈니스 전반에 걸쳐 유비쿼터스 언어를 활용하여 도메인 및 하위 도메인을 기반으로 아키텍처를 설계해야 한다는 가정에서 시작한다. 비즈니스 관점에서 모델링할 때 시스템에 대한 더 나은 이해, 비즈니스 도메인의 기술 표현에 대한 더 쉬운 정의, 팀이 운영해야 하는 명확한 경계 등 여러 이점을 제공한다.\n자동화 문화 강력한 자동화 문화를 통해 저 빠르고 안정적인 방식으로 마이크로서비스를 적용할 수 있으며, 마이크로서비스 아키텍처의 핵심 프로세스 중 하나이다.\n구현 세부 정보 숨기기 동일한 비즈니스 도메인 내에서 서비스를 캡슐화하며, API를 통해 필요한 것만 노출하고 나머지 구현은 숨긴다. 이를 통해 시스템의 나머지 부분에 영향을 주지 않고 내부 논리를 원하는 대로 변경할 수 있다.\n모든 것을 분산화 기술적 문제가 있더라도 모놀리스를 사용하면 조직에서 가장 경험이 많은 사람들이 주요 의사 결정을 내리는 경우가 많고, 직면한 문제에 대해 타협점을 만들고 넘어가는 경우가 많지만, 이러한 결정을 분산화하면 팀이 직면한 문제를 기반으로 기술적인 방향을 취할 수 있으므로 전체 시스템에 긍정적 영향을 미칠 수 있다.\n독립적 배포 마이크로서비스의 핵심 중 하나이다. 모놀리스를 사용하면 제품을 배포하고 롤백하는데 많은 시간이 걸리며 매번 전체 시스템을 배포해야 한다. 하지만 독립적인 배포를 통해 전체 API 계층을 손상시킬 가능성을 줄이면서 자율적으로 배포할 수 있으며, 더 적은 위험으로 마이크로서비스의 새 버전을 출시할 수도 있다.\n실패 격리 서비스 장애 등으로 하나 이상의 마이크로서비스에 연결할 수 없는 경우 시스템의 나머지 부분은 사용할 수 있어야 한다. 마이크로서비스가 자율적이고 독릭적이라는 사실은 장애 격리의 개념을 강화한다.\n고도로 관찰 가능 일반적으로 모놀리식 아키텍처를 선호하는 이유 중 하나는 단일 시스템을 관찰하기 때문이다. 마이크로서비스는 많은 자유와 유연성을 제공하지만 이것들이 무료는 아니다. 로그와 모니터링을 주시해야 하며, 특정 클라이언트 요청을 끝까지 파악할 준비가 되어 있어야 한다. 따라서 시스템을 고도로 관찰 가능하게 유지하는 것은 마이크로서비스의 주요 과제 중 하나이다.\n참고 링크  Micro Frontends   2편에서 계속\n","date":"2022-04-19T00:00:00+09:00","permalink":"https://JungKyuHyun.github.io/p/micro-frontend-1%ED%8E%B8/","title":"Micro-Frontend - 1편"},{"content":"근황 오랫만에 다시 글을 쓰는거 같다. 의도적으로 안썼다기보단 사실 너무 바빴다는게 맞을거 같다. 특히 최근에는 일이 많다기보다는 go언어로 백엔드 업무를 처음 배우다보니 글을 쓰며 공부할 수가 없었다. 업무에 조금 익숙해 지면 관련된 내용들은 차근차근 포스팅할 예정이다.\nhugo와의 첫 만남 근데 지금이 조금 익숙해진 시점이긴 하다. 물론 배울게 아직 산덤이지만, 일과 후에는 조금 시간이 남아 다시 공부를 하면서 글을 다시 써볼려고 한다. 근데 다시 시작해 보려고 하니 쓰기가 싫어졌다. 왜냐,\n나의 블로그의 가독성을 좋지 못했다. 다시 봐야지 하고 내가 내 글을 봐도 가독성이 늘 떨어진다고 생각했지만, 테마를 바꾸기에는 다시 설정을 하는 수고가 싫었으며, 테마를 바꾼다고 엄청 나아질 것이라고 생각도 하지 않았다(물론 잘 사용하시는 분들도 있지만, 적어도 나에겐 말이다). 그래서 깃북을 사용해 왔는데, 깃북을 확실히 티스토리보다 가독성이 훨씬 좋았으며, 목차별로 내용을 잘 그룹지을 수가 있는 점이 좋았다. 하지만 UI 커스텀이 너무 제한적이라 내가 할 수 있는 것들이 없었다. 그렇게 고민하던중 현회사의 팀장님이 블로그를 변경하신다는 말을 듣고 어떤 프로젝트를 사용하시는지 여쭤봤다. 이렇게 알게된 것이 바로 hugo이다.\n다양한 Theme, 반응형도 되고, Ruby도 안쓰네? 😃 과거 jekyll를 통해 깃허브 블로그를 만들었으나, 처음 만들어 보는거기도 하고 처음 접해보는 루비 명령어들이 너무 낯설었다. 물론 처음만 하면 된다고 하지만, 그때의 경험이 별로여서 그런지 jekyll는 싫었는데, hugo는 아주 매력적이었다. go로 작성하여 나중에 기여도 할 수 있었고, 이미지 프로세싱이나 국제화 등 더 많은 기능이 제공되어 고민 없이 선택하게 되었다.\n설치 방법(github 페이지랑 연동하기) 먼저 두 개의 레포를 준비한다. github action을 통해 하나만 사용해도 될거 같긴한데, 여튼 남들이 다 하는데로 두개 준비했다.\nRepo 2개 준비  원하는 이름의 repo 하나(이하 blog repo로 명명) {username}.github.io로 네이밍한 repo 하나  blog repo에 기존 작업 내용 동기화(push) blog repo에 기존 작업 내용 동기화(push)한다. 내가 작업한 내용들은 기본적으로 이 repo에 보관할 것이다.\nroot 폴더에 public 폴더가 있다면 삭제 root 폴더에 public 폴더가 있다면 삭제한다. 나중엔 안해도 되었는데, 초반에는 이 부분에서도 에러가 났다.\ngit submodule 추가 서브 모듈을 만들어 빌드된 public 폴더가 다른 remote origin을 가지게 설정해 주는 작업이다.\n1 2 3 4 5 6 7  # ex) 나의 경우 git submodule add --name khblog -b main https://github.com/JungKyuHyun/JungKyuHyun.github.io.git public $ git submodule add --name {서브모드 별명(자유)} -b main https://github.com/{username}/{username}.github.io.git public # 아래와 같은 응답이 나온다면 잘 진행된 상황. # warning: You appear to have cloned an empty repository. # fatal: \u0026#39;origin/main\u0026#39; is not a commit and a branch \u0026#39;main\u0026#39; cannot be created from it # Unable to checkout submodule \u0026#39;public\u0026#39;   deploy.sh 작성하기 root folder에 deploy.sh 파일 생성 및 아래 코드를 붙여 넣는다. 몇가지 추가 설명은 스크립트에 같이 써놨으며 추가 설명에 해당되는 내용이 없다면 수정할 내용도 없다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #!/bin/bash  echo -e \u0026#34;\\\\033[0;32mDeploying updates to GitHub...\\\\033[0m\u0026#34; # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # 테마를 사용한다면 테마 이름을 쓰라고 적혀있지만, hugo module로 받았다면 이 부분은 별도로 수정하지 않아도 되는거 같다. # 오히려 수정하면, theme이 아래 폴더가 텅텅 비었다는 에러가 나온다. # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. (master 브랜치인 경우 master) git push origin main # Come Back up to the Project Root cd ..   deploy! 아래 코드를 콘솔 창에 입력하면, 빌드된 내역이 public에 담기고 {username}.github.io 레포로 push되는 것을 확인할 수 있다.\n1  $ ./deploy.sh \u0026#34;커밋 메시지\u0026#34;   (Optional) 만약 권한 관련 에러가 나온다면, 권한을 부여해 주자.\n1  $ chmod 777 deploy.sh   연동 작업 완료 후 글이나 테마 등을 수정하여 호스팅된 깃허브 페이지에 반영하고 싶다면, 아래 명령어를 통해 반영하면 된다.\n1  $ ./deploy.sh \u0026#34;커밋 메시지\u0026#34;   만약 글 작성이 끝나지 않았다면 blog-repo로만 push하면 실제 호스팅된 블로그에는 반영이 안되게 하면 된다.\n 글을 테스트 해볼겸 적은 내용이라 두서가 없거나 내용을 조금 뺀 것도 있으니 참고 부탁드립니다 :)\n","date":"2022-04-18T00:00:00+09:00","image":"https://JungKyuHyun.github.io/p/hugo%EB%A1%9C-%EC%9D%B4%EC%82%AC%ED%95%98%EA%B8%B0/bye-gitbook_hu2f6adbe75a18b51fec71244f39c460ed_65361_120x120_fill_box_smart1_3.png","permalink":"https://JungKyuHyun.github.io/p/hugo%EB%A1%9C-%EC%9D%B4%EC%82%AC%ED%95%98%EA%B8%B0/","title":"Hugo로 이사하기"}]